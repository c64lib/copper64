/*
 * c64lib/copper64/copper64.asm
 *
 * A library that realizes a copper-like functionality of firing certain predefined handlers 
 * at programmable raster lines. This library utilizes raster interrupt functionality of VIC-II.
 *
 * Author:    Maciej Malecki
 * License:   MIT
 * (c):       2018
 * GIT repo:  https://github.com/c64lib/copper64
 */
#importonce
#import "common/common.asm"
#import "common/mem.asm"
#import "chipset/vic2.asm"
#import "chipset/cia.asm"

.filenamespace c64lib

/*
 * Codes of predefined copper64 handlers.
 *
 * Note, that by default each handler is disabled thus not available in assembled code.
 * In order to enable given handler, define IRQH_<handlerName> symbol using #define directive.
 * Assembling will fail, if too many handlers are enabled - summarized code for all handlers must
 * fit into single 256b memory page.
 */
.label IRQH_BORDER_COL          = 1
.label IRQH_BG_COL_0            = 2
.label IRQH_BH_COL_1            = 3
.label IRQH_BH_COL_2            = 4
.label IRQH_BH_COL_3            = 5
.label IRQH_BORDER_BG_0_COL     = 6
.label IRQH_BORDER_BG_0_DIFF    = 7
.label IRQH_MEM_BANK            = 8
.label IRQH_MEM                 = 9
.label IRQH_MODE_MEM_BANK       = 10
.label IRQH_MODE_MEM            = 11
.label IRQH_MODE                = 12
.label IRQH_JSR                 = 13

.label IRQH_CTRL_RASTER8        = %10000000
.label IRQH_SKIP                = $00
.label IRQH_LOOP                = $FF

/*
 * Stabilizes interrupt.
 */
.macro stabilize(secondIrqHandler) {
  lda #<secondIrqHandler
  sta IRQ_LO
  lda #>secondIrqHandler
  sta IRQ_HI
  inc RASTER // TODO what if raster is higher than 255? quick check on overflow needed...
  inc IRR
  tsx
  cli
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop // TODO probably too many NOPs
}

.macro cycleRaster(count) {
  ldx #count
  dex
  bne *-1
  bit $00
  lda RASTER
  cmp RASTER
  beq *+2
}

.macro setMasterIrqHandler(copperIrq) {
  lda #<copperIrq
  sta c64lib.IRQ_LO
  lda #>copperIrq
  sta c64lib.IRQ_HI
}

/*
 * Creates single entry of copper list.
 * raster - at which raster line (supports all raser lines, also > 255)
 * handler - handler code
 * arg1 - argument 1 of raster handler
 * arg2 - argument 2 of raster handler
 */
.macro @copperEntry(raster, handler, arg1, arg2) {
  .if (raster >= 256) {
    .byte 128 + handler  
  }  else {
    .byte handler
  }
  .byte <raster, arg1, arg2
}

/*
 * Creates end of copper list with looping directive.
 */
.macro @copperLoop() {
  copperEntry(0, IRQH_LOOP, 0, 0)
}

/*
 * Requires 3 bytes on zero page: 2 subsequent for listStart and 1 byte for list pointer (Y)
 *
 * listStart - begin address of display list stored on zero page
 * listPtr - address for Y reg storage
 */
.macro @initCopper(listStart, listPtr) {
  // here we do initialize and install first interrupt handler
  lda #$00
  sta listPtr
  sei
  // disable IRQs generated by CIAs
  lda #$7F                     
  sta CIA1_IRQ_CONTROL
  sta CIA2_IRQ_CONTROL
  lda CIA1_IRQ_CONTROL
  lda CIA2_IRQ_CONTROL
  // enable IRQ generated by VIC-II
  lda #IMR_RASTER
  sta IMR
  setMasterIrqHandler(copperIrq)

  // TODO better handling of nmi needed
  lda #<nmi
  sta c64lib.NMI_LO
  lda #>nmi
  sta c64lib.NMI_HI
  ldy listPtr
  jsr fetchNext
  sty listPtr
  cli
  rts // end of initialization
  
copperIrq:                    // major interrupt handler for copper64; interrupt not stabilized at this point
  :debugBorderStart()
  pha
  tya
  pha
  txa
  pha
  ldy listPtr
irqHandlersJump:
  jmp irqHandlers               // 3: LO byte of jump address will be modified every time new item is fetched from the list
irqHandlersReturn:              // here we jump back from handler routine, due to jmp instead jsr we save 6 cycles
  jsr fetchNext                 // 6
  sty listPtr
  dec IRR                       // ACK the interrupt
  pla
  tax
  pla
  tay
  pla
  :debugBorderEnd()
  rti
fetchNext:                      // fetch new copper list item, y should point at current list position
  lda (listStart),y             // 5: < 1st byte - control
  cmp #IRQH_LOOP                // 2
  beq loop                      // 2: if $FF then loop copper list
  cmp #IRQH_SKIP                // 2
  beq skip                      // 2: if #$FF then skip copper list position
  rol                           // 2
  bcs raster8                   // 2: 7 bit set means we use 8th bit of raster irq 
  lda CONTROL_1                 // 4:
  and #neg(CONTROL_1_RASTER8)   // 2: 7..0 bits are enough for raster irq
  jmp nextRaster8               // 3
raster8:
  ora #CONTROL_1_RASTER8        // 2
nextRaster8:
  sta CONTROL_1
  lda (listStart),y             // 5: it is more efficient to load it once more (5) instead of tax,txa,ror (6)
  and #%00011111                // 2: clear not significant bits to get command id, max 30 values, value 0 is not used
  tax                           // 2
  iny                           // 2
  lda (listStart),y             // 5: < 2nd byte - raster irq counter bits 7..0
  iny                           // 2
  sta RASTER                    // 4: program raster irq
  lda jumpTable,x               // 4: load low byte from jump table
  sta irqHandlersJump + 1       // 4: store low byte of address
  rts                           // 6
loop:                           // we do loop the copper list
  ldy #$00
  jmp fetchNext
skip:                           // we do skip the copper list, useful for disabling list item temporarily
  iny
  iny
  iny
  iny
  jmp fetchNext
nmi:
  rti

  /*
   * Switchable IRQ handlers.
   */
  .align $100
irqHandlers:
  .print "IRQ Handlers start at: " + toHexString(irqHandlers)
  irqh1:                        // (22) border color
    #if IRQH_BORDER_COL
      #if IRQH_BORDER_COL_STABLE
        stabilize(irqh1Stabilized)
      irqh1Stabilized:
        txs
        cycleRaster(7)
      #endif
    lda (listStart),y           // 5
    sta BORDER_COL              // 4
      #if IRQH_BORDER_COL_STABLE 
        setMasterIrqHandler(copperIrq)
      #endif
    jmp irqhReminder            // 3
    #endif
  irqh2:                        // (22) background color 0
    #if IRQH_BG_COL_0
      #if IRQH_BG_COL_0_STABLE
        stabilize(irqh2Stabilized)
      irqh2Stabilized:
        txs
        cycleRaster(8)
      #endif
    lda (listStart),y           // 5
    sta BG_COL_0                // 4
      #if IRQH_BG_COL_0_STABLE 
        setMasterIrqHandler(copperIrq)
      #endif
    jmp irqhReminder            // 3
    #endif
  irqh3:                        // (22) background color 1
    #if IRQH_BG_COL_1
    lda (listStart),y           // 5
    sta BG_COL_1                // 4
    jmp irqhReminder            // 3
    #endif
  irqh4:                        // (22) background color 2
    #if IRQH_BG_COL_2
    lda (listStart),y           // 5
    sta BG_COL_2                // 4
    jmp irqhReminder            // 3
    #endif
  irqh5:                        // (22) background color 3
    #if IRQH_BG_COL_3
    lda (listStart),y           // 5
    sta BG_COL_3                // 4
    jmp irqhReminder            // 3
    #endif
  irqh6:                        // (26) border and background color 0 same
    #if IRQH_BORDER_BG_0_COL
      #if IRQH_BORDER_BG_0_COL_STABLE
        stabilize(irqh6Stabilized)
      irqh6Stabilized:
        txs
        cycleRaster(7)
      #endif
    lda (listStart),y           // 5
    sta BORDER_COL              // 4
    sta BG_COL_0                // 4
      #if IRQH_BORDER_BG_0_COL_STABLE 
        setMasterIrqHandler(copperIrq)
      #endif
    jmp irqhReminder            // 3
    #endif
  irqh7:                        // (31) border and background color 0 different
    #if IRQH_BORDER_BG_0_DIFF
    lda (listStart),y           // 5
    sta BORDER_COL              // 4
    iny                         // 2
    lda (listStart),y           // 5
    sta BG_COL_0                // 4
    jmp irqhReminder2Args       // 3
    #endif
  irqh8:                        // (28) set vic-ii memory and bank
    #if IRQH_MEM_BANK
    lda (listStart),y           // 5
    sta MEMORY_CONTROL          // 4
    iny                         // 2
    lda (listStart),y           // 4
    ora CIA2_DATA_PORT_A        // 4
    sta CIA2_DATA_PORT_A        // 4
    jmp irqhReminder2Args       // 3
    #endif
  irqh9:                        // (16) set vic-ii memory
    #if IRQH_MEM
    lda (listStart),y           // 5
    sta MEMORY_CONTROL          // 4
    jmp irqhReminder            // 3
    #endif
  irqh10:                       // mode mem bank
    #if IRQH_MODE_MEM_BANK
    #endif
  irqh11:                       // mode mem
    #if IRQH_MODE_MEM
    #endif
  irqh12:                       // mode (control 1 | control 2)
    #if IRQH_MODE
    lda CONTROL_1               // 4               
    and #neg(CONTROL_1_ECM | CONTROL_1_BMM) // 3
    ora (listStart),y           // 4
    sta CONTROL_1               // 4
    iny                         // 2
    lda CONTROL_2               // 4
    and #neg(CONTROL_2_MCM)     // 3
    ora (listStart),y           // 4
    sta CONTROL_2
    jmp irqhReminder2Args       // 3
    #endif
  irqh13:                       // jsr (jsr address lo | lsr address hi)
    #if IRQH_JSR
    lda (listStart),y           // 4
    sta irqh13jsr+1             // 4
    iny                         // 2
    lda (listStart),y           // 4
    sta irqh13jsr+2             // 4
    sty listPtr
  irqh13jsr:
    jsr $0000
    ldy listPtr
    jmp irqhReminder2Args
    #endif
  irqhReminder:
    iny
  irqhReminder2Args:
    iny
    jmp irqHandlersReturn
  irqhEnd:
  .print "Size of aggregated code of IRQ handlers: " + (irqhReminder - irqHandlers) + " bytes."
  .assert "Size of aggregated code of IRQ handlers must fit into one memory page (256b)", irqhReminder - irqHandlers <= 256, true
  
  /* 
   * Jump table for IRQ handlers.
   *
   * For sake of efficiency, jump table only stores lo address of handler. 
   * It is assumed that hi address is always the same.
   */
  .if (256 - (irqhEnd - irqHandlers) < 32) {
    // jumpTable(s) are merged into irqHandlers space if only they fit together into 256b
    .align $100
  }
jumpTable:
  .print "Jump table starts at: " + toHexString(jumpTable)
  .byte $00, <irqh1, <irqh2, <irqh3, <irqh4, <irqh5, <irqh6, <irqh7 // position 0 is never used
  .byte <irqh8, <irqh9, <irqh10, <irqh11, <irqh12, <irqh13
jumpTableEnd:
  .print "Jump table size: " + [jumpTableEnd - jumpTable] + " bytes."
  .assert "Size of Jump table must fit into one memory page (256b)", jumpTableEnd - jumpTable <= 256, true
}
